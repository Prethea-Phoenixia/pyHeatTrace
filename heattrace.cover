    1: import tkinter as tk
    1: import tkinter.ttk as ttk
    1: import tkinter.filedialog as tkfiledialog
    1: import tkinter.messagebox as tkmessagebox
    1: from ttkthemes import ThemedTk
    1: import subprocess as sp
       
    1: """
       Jinpeng Zhai
       Main script to analyze a Python file, using a tk-GUI for interactivity.
       
       """
       
    1: import os
    1: import queue
    1: from threading import Thread
       
    1: import psutil
       
       
    2: class heatTrace(tk.Frame):
    1:     def __init__(self, parent):
               # use this instead of super() due to multiple inheritance
    1:         ttk.Frame.__init__(self, parent)
               # initially, let the fileVar be pointed at this file itself.
    1:         self.pathVar = tk.StringVar(value=os.path.normpath(__file__))
    1:         self.pack(expand=1, fill="both")  # pack the heatTrace frame in root.
       
               # allow 3,1 to unconditionally take up more space as the window is resized
    1:         self.columnconfigure(1, weight=1)
    1:         self.rowconfigure(3, weight=1)
       
               # group of widgets responsible for selecting the target file.
    3:         ttk.Button(
    1:             self, text="Select File", underline=0, command=self.load
    1:         ).grid(row=0, column=0, sticky="nsew", padx=2, pady=2)
    2:         ttk.Entry(self, textvariable=self.pathVar, state="disabled").grid(
    1:             row=0, column=1, sticky="nsew", padx=2, pady=2
               )
    2:         ttk.Button(self, text="Run Trace", command=self.trace).grid(
    1:             row=0, column=2, sticky="nsew", padx=2, pady=2
               )
       
    1:         mainOptionFrame = ttk.LabelFrame(self, text="Options")
    2:         mainOptionFrame.grid(
    1:             row=1, column=0, columnspan=3, sticky="nsew", padx=10, pady=10
               )
       
    6:         for i in range(5):
    5:             mainOptionFrame.columnconfigure(i, weight=1)
       
    1:         self.arg_c = tk.IntVar()
    3:         ttk.Checkbutton(
    1:             mainOptionFrame, text="--count", variable=self.arg_c
    1:         ).grid(row=0, column=0, sticky="nsew", padx=2, pady=2)
       
    1:         self.arg_t = tk.IntVar()
    3:         ttk.Checkbutton(
    1:             mainOptionFrame, text="--trace", variable=self.arg_t
    1:         ).grid(row=0, column=1, sticky="nsew", padx=2, pady=2)
       
    1:         self.arg_l = tk.IntVar()
    3:         ttk.Checkbutton(
    1:             mainOptionFrame, text="--listfuncs", variable=self.arg_l
    1:         ).grid(row=0, column=2, sticky="nsew", padx=2, pady=2)
       
    1:         self.arg_r = tk.IntVar()
    3:         ttk.Checkbutton(
    1:             mainOptionFrame, text="--report", variable=self.arg_r
    1:         ).grid(row=0, column=3, sticky="nsew", padx=2, pady=2)
       
    1:         self.arg_T = tk.IntVar()
    3:         ttk.Checkbutton(
    1:             mainOptionFrame, text="--trackcalls", variable=self.arg_T
    1:         ).grid(row=0, column=4, sticky="nsew", padx=2, pady=2)
       
    1:         modifierFrame = ttk.LabelFrame(self, text="Modifiers")
    2:         modifierFrame.grid(
    1:             row=2, column=0, columnspan=3, sticky="nsew", padx=10, pady=10
               )
       
    5:         for i in range(4):
    4:             modifierFrame.columnconfigure(i, weight=1)
       
    1:         self.arg_m = tk.IntVar()
    3:         ttk.Checkbutton(
    1:             modifierFrame, text="--missing", variable=self.arg_m
    1:         ).grid(row=0, column=0, sticky="nsew", padx=2, pady=2)
       
    1:         self.arg_s = tk.IntVar()
    3:         ttk.Checkbutton(
    1:             modifierFrame, text="--summary", variable=self.arg_s
    1:         ).grid(row=0, column=1, sticky="nsew", padx=2, pady=2)
       
    1:         self.arg_R = tk.IntVar()
    3:         ttk.Checkbutton(
    1:             modifierFrame, text="--no-report", variable=self.arg_R
    1:         ).grid(row=0, column=2, sticky="nsew", padx=2, pady=2)
       
    1:         self.arg_g = tk.IntVar()
    3:         ttk.Checkbutton(
    1:             modifierFrame, text="--timing", variable=self.arg_g
    1:         ).grid(row=0, column=3, sticky="nsew", padx=2, pady=2)
       
    1:         self.fargs = tk.StringVar()
    2:         ttk.Label(modifierFrame, text="--file").grid(
    1:             row=1, column=0, sticky="nsew", padx=2, pady=2
               )
    2:         ttk.Entry(modifierFrame, textvariable=self.fargs).grid(
    1:             row=1, column=1, columnspan=3, sticky="nsew", padx=2, pady=2
               )
       
    1:         self.Cargs = tk.StringVar()
    2:         ttk.Label(modifierFrame, text="--coverdir").grid(
    1:             row=2, column=0, sticky="nsew", padx=2, pady=2
               )
    2:         ttk.Entry(modifierFrame, textvariable=self.Cargs).grid(
    1:             row=2, column=1, columnspan=3, sticky="nsew", padx=2, pady=2
               )
       
    2:         self.ignored_module = tk.StringVar(
    1:             value="sys.prefix" + os.pathsep + "sys.exec_prefix"
               )
    2:         ttk.Label(modifierFrame, text="--ignored_module").grid(
    1:             row=3, column=0, sticky="nsew", padx=2, pady=2
               )
    2:         ttk.Entry(modifierFrame, textvariable=self.ignored_module).grid(
    1:             row=3, column=1, columnspan=3, stick="nsew", padx=2, pady=2
               )
       
    1:         self.ignored_dir = tk.StringVar()
    2:         ttk.Label(modifierFrame, text="--ignored_dir").grid(
    1:             row=4, column=0, sticky="nsew", padx=2, pady=2
               )
    2:         ttk.Entry(modifierFrame, textvariable=self.ignored_dir).grid(
    1:             row=4, column=1, columnspan=3, stick="nsew", padx=2, pady=2
               )
       
    1:         self.ttyText = tk.Text(self, wrap=tk.CHAR, undo=True)
    1:         self.ttyText.grid(row=3, column=0, columnspan=3, sticky="nsew")
    2:         self.ttyText.config(
    1:             background="black",
    1:             foreground="green",
    1:             insertbackground="white",
    1:             selectbackground="grey",
    1:             selectforeground="green",
               )
       
    2:         self.ttyText.tag_config(
    1:             "stdout",
    1:             background="black",
    1:             foreground="white",
    1:             selectbackground="grey",
    1:             selectforeground="black",
               )
    2:         self.ttyText.tag_config(
    1:             "stderr",
    1:             background="black",
    1:             foreground="red",
    1:             selectbackground="grey",
    1:             selectforeground="red",
               )
       
    1:         operationFrame = ttk.LabelFrame(self, text="Operations")
    1:         operationFrame.grid(row=4, column=0, columnspan=3, stick="nsew")
       
    4:         for i in range(3):
    3:             operationFrame.columnconfigure(index=i, weight=1)
       
    2:         ttk.Button(operationFrame, text="Reset", command=self.restart).grid(
    1:             row=0, column=0, sticky="nsew"
               )
       
               # make queues for keeping stdout and stderr whilst it is transferred between threads
    1:         self.outQueue = queue.Queue()
    1:         self.errQueue = queue.Queue()
       
               # keep track of where any line that is submitted starts
    1:         self.line_start = 0
       
               # make the enter key call the self.enter function
    1:         self.ttyText.bind("<Return>", self.enter)
               # and make sure the user does not delete past the starting point.
    1:         self.ttyText.bind("<KeyRelease>", self.postKey)
       
    1:         self.startSubprocess()
    1:         self.writeLoop()  # start the write loop in the main thread
       
    1:     def load(self):
               filePath = tkfiledialog.askopenfilename(
                   title="Load Programme to be Analyzed",
                   filetypes=(("Python Programme", "*.py"),),
                   defaultextension=".py",
                   initialfile="main.py",
                   initialdir=".",  # set to local dir relative to where this script is stored
               )
       
               exceptionMsg = "Exception:"
               if filePath == "":
                   tkmessagebox.showinfo(exceptionMsg, "No File Selected")
               else:
                   self.pathVar.set(os.path.normpath(filePath))
                   self.navigateToFolder()
       
    1:     def trace(self):
               fileName = os.path.basename(self.pathVar.get())
       
               options = " ".join(
                   (
                       v
                       for v in (
                           ("-c" if self.arg_c.get() else None),
                           ("-t" if self.arg_t.get() else None),
                           ("-l" if self.arg_l.get() else None),
                           ("-r" if self.arg_r.get() else None),
                           ("-T" if self.arg_T.get() else None),
                           (
                               "-f " + self.fargs.get()
                               if self.fargs.get() != ""
                               else None
                           ),
                           (
                               "-C " + self.Cargs.get()
                               if self.Cargs.get() != ""
                               else None
                           ),
                           ("-m" if self.arg_m.get() else None),
                           ("-s" if self.arg_s.get() else None),
                           ("-R" if self.arg_R.get() else None),
                           ("-g" if self.arg_g.get() else None),
                           (
                               "--ignore-module=" + self.ignored_module.get()
                               if self.ignored_module.get()
                               else None
                           ),
                           (
                               "--ignore-dir=" + self.ignored_module.get()
                               if self.ignored_dir.get()
                               else None
                           ),
                       )
                       if v is not None
                   )
               )
               traceCommand = " ".join(["python -m trace", options, fileName, "\n"])
               self.p.stdin.write(traceCommand.encode())
               self.p.stdin.flush()
       
    1:     def destroy(self):  #
               """This is the function that is automatically called when the widget is
               destroyed, and overrides the widget's default destroy()"""
    1:         self.alive = False
               # write exit() to the console in order to stop it running
       
    1:         self.p.terminate()  # this, if the above didn't work, sends a Termination signal
    1:         self.p.kill()  # and a kill signal. On windows this is the same.
               # these methods are a lot more effective than sending "exit" and flushing
       
               # call the destroy methods to properly destroy widgets
    1:         self.ttyText.destroy()
    1:         tk.Frame.destroy(self)
       
    1:     def enter(self, e):
               """The <Return> key press handler"""
               self.postKey(None)
               # ensure the Enter key, if pressed simultaneousely, effectively
               # "interrupts" other entries by forcing the postKey to be called.
               string = self.ttyText.get(1.0, tk.END)[self.line_start :]
               self.line_start += len(string)
               self.p.stdin.write(string.encode())
               self.p.stdin.flush()
       
    1:     def postKey(self, e):
               ttyNow, ttyNowTagDict = self.ttyNow
               ttyNew = self.ttyText.get(1.0, tk.END)[: len(ttyNow)]
               if ttyNew != ttyNow:
                   self.ttyText.edit_undo()
                   self.ttyText.edit_reset()
       
                   for tag, ranges in ttyNowTagDict.items():
                       for startIndex, endIndex in zip(ranges[::2], ranges[1::2]):
                           self.ttyText.tag_add(tag, startIndex, endIndex)
       
    1:     def readFromProccessOut(self):
               """To be executed in a separate thread to make read non-blocking"""
    4:         while self.alive:
    3:             data = self.p.stdout.raw.read(1024).decode()
    3:             self.outQueue.put(data)
       
    1:     def readFromProccessErr(self):
               """To be executed in a separate thread to make read non-blocking"""
    2:         while self.alive:
    1:             data = self.p.stderr.raw.read(1024).decode()
    1:             self.errQueue.put(data)
       
    1:     def writeLoop(self):
               """Used to write data from stdout and stderr to the Text widget"""
               # if there is anything to write from stdout or stderr, then write it
       
  375:         if not self.errQueue.empty():
                   self.write(self.errQueue.get(), tag="stderr")
  375:         if not self.outQueue.empty():
    2:             out = self.outQueue.get()
    2:             self.write(out, tag="stdout")
       
               # run this method again after 10ms
  375:         if self.alive:
  375:             self.after(10, self.writeLoop)
       
    1:     def clear(self):
               self.line_start = 0
               self.ttyText.delete(1.0, tk.END)
       
    1:     def navigateToFolder(self):
               folderPath = os.path.dirname(self.pathVar.get())
       
               self.p.stdin.write(
                   "cd {:}\n".format(folderPath).encode()
               )  # This is also platform independent.
       
               self.p.stdin.flush()
       
    1:     def write(self, string, tag=None):
    2:         self.ttyText.insert(tk.END, string, tag)
    2:         self.ttyText.see(tk.END)
    2:         self.ttyText.mark_set(tk.INSERT, tk.END)
       
    2:         self.line_start += len(string)
       
    2:         self.ttyText.edit_reset()
       
    2:         self.ttyNow = (
    2:             self.ttyText.get(1.0, tk.END)[: self.line_start],
    8:             {tag: self.ttyText.tag_ranges(tag) for tag in ("stdout", "stderr")},
               )
       
    1:     def startSubprocess(self):
               # open a subprocess to this script.
    2:         self.p = sp.Popen(
    1:             ["cmd"], stdout=sp.PIPE, stdin=sp.PIPE, stderr=sp.PIPE
               )
       
               # a daemon to keep track of the threads so they can stop running
    1:         self.alive = True
               # start the functions that get stdout and stderr in separate threads
    1:         Thread(target=self.readFromProccessOut).start()
    1:         Thread(target=self.readFromProccessErr).start()
       
    1:     def endSubprocess(self):
               self.alive = False
       
               # use psutil (a cross platform tool) to recursively kill the children
               # to ensure a clean exit.
               process = psutil.Process(self.p.pid)
               for childProcess in process.children(recursive=True):
                   childProcess.kill()
               process.kill()
       
               # the original way of ending subprocesses.
               self.p.terminate()
               self.p.kill()
       
    1:     def restart(self):
               self.endSubprocess()
               self.clear()
               self.startSubprocess()
       
       
    1: def main():
    1:     root = ThemedTk(theme="equilux")
           # root.option_add("*tearOff", False)
           # root.title("pyHeatTrace")
       
           # menubar = tk.Menu(root)
           # root.config(menu=menubar)
    1:     heatTrace(root)
    1:     root.mainloop()
       
       
    1: if __name__ == "__main__":
    1:     main()
