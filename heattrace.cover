    1: import tkinter as tk
    1: import tkinter.ttk as ttk
    1: import tkinter.filedialog as tkfiledialog
    1: import tkinter.messagebox as tkmessagebox
    1: import subprocess
       
    1: """
       Jinpeng Zhai
       Main script to analyze a Python file, using a tk-GUI for interactivity
       """
       
    1: import os
    1: import queue
    1: from threading import Thread
       
       
    2: class heatTrace(tk.Frame):
    1:     def __init__(self, parent, menubar):
               # use this instead of super() due to multiple inheritance
    1:         ttk.Frame.__init__(self, parent)
       
    1:         self.fileVar = tk.StringVar(value=os.path.normpath(__file__))
       
    1:         self.pack(expand=1, fill="both")  # pack the heatTrace frame in root.
       
    1:         fileMenu = tk.Menu(menubar)
    2:         menubar.add_cascade(
    1:             label="File", underline=0, menu=fileMenu
               )  # cascading file menu
    2:         fileMenu.add_command(
    1:             label="Load Programme", underline=0, command=self.load
               )  # command button to load programmes
       
    1:         self.columnconfigure(1, weight=1)
       
    2:         ttk.Label(self, text="File Selected", underline=0, anchor="e").grid(
    1:             row=0, column=0, sticky="nsew"
               )
       
    2:         ttk.Entry(self, textvariable=self.fileVar, state="disabled").grid(
    1:             row=0, column=1, sticky="nsew"
               )
    2:         ttk.Button(self, text="Run", command=self.trace).grid(
    1:             row=0,
    1:             column=2,
    1:             sticky="nsew",
               )
       
    1:         self.ttyText = tk.Text(self, wrap=tk.WORD)
    1:         self.ttyText.grid(row=1, column=0, columnspan=3, sticky="nsew")
       
               # open a subprocess to this script.
    2:         self.p = subprocess.Popen(
    1:             ["cmd"],  # PLATFORM DEPENDENCY!
    1:             stdout=subprocess.PIPE,
    1:             stdin=subprocess.PIPE,
    1:             stderr=subprocess.PIPE,
               )
       
               # make queues for keeping stdout and stderr whilst it is transferred between threads
    1:         self.outQueue = queue.Queue()
    1:         self.errQueue = queue.Queue()
       
               # keep track of where any line that is submitted starts
    1:         self.line_start = 0
       
               # make the enter key call the self.enter function
    1:         self.ttyText.bind("<Return>", self.enter)
       
               # a daemon to keep track of the threads so they can stop running
    1:         self.alive = True
               # start the functions that get stdout and stderr in separate threads
    1:         Thread(target=self.readFromProccessOut).start()
    1:         Thread(target=self.readFromProccessErr).start()
       
               # start the write loop in the main thread
    1:         self.writeLoop()
       
    1:     def load(self):
               fileVar = tkfiledialog.askopenfilename(
                   title="Load Programme to be Analyzed",
                   filetypes=(("Python Programme", "*.py"),),
                   defaultextension=".py",
                   initialfile="main.py",
                   initialdir="./",  # set to local dir relative to where this script is stored
               )
       
               exceptionMsg = "Exception Occured during Load"
               if fileVar == "":
                   tkmessagebox.showinfo(exceptionMsg, "No File Selected")
                   return
       
               self.fileVar.set(os.path.normpath(fileVar))
       
    1:     def trace(self):
               filePath = self.fileVar.get()
       
               result = subprocess.run(
                   ["python", "-m", "trace", "--count", filePath],
                   capture_output=True,
                   # shell=True,
               )
       
               print(result)
       
    1:     def destroy(self):  #
               """This is the function that is automatically called when the widget is
               destroyed, and overrides the widget's default destroy()"""
    1:         self.alive = False
               # write exit() to the console in order to stop it running
    1:         self.p.stdin.write("exit\n".encode())
               # TODO: make this platform independent
    1:         self.p.stdin.flush()
               # call the destroy methods to properly destroy widgets
    1:         self.ttyText.destroy()
    1:         tk.Frame.destroy(self)
       
    1:     def enter(self, e):
               """The <Return> key press handler"""
               string = self.ttyText.get(1.0, tk.END)[self.line_start :]
               self.line_start += len(string)
               self.p.stdin.write(string.encode())
               self.p.stdin.flush()
       
    1:     def readFromProccessOut(self):
               """To be executed in a separate thread to make read non-blocking"""
    4:         while self.alive:
    3:             data = self.p.stdout.raw.read(1024).decode()
    3:             self.outQueue.put(data)
       
    1:     def readFromProccessErr(self):
               """To be executed in a separate thread to make read non-blocking"""
    1:         while self.alive:
    1:             data = self.p.stderr.raw.read(1024).decode()
                   self.errQueue.put(data)
       
    1:     def writeLoop(self):
               """Used to write data from stdout and stderr to the Text widget"""
               # if there is anything to write from stdout or stderr, then write it
   71:         if not self.errQueue.empty():
                   self.write(self.errQueue.get())
   71:         if not self.outQueue.empty():
    2:             self.write(self.outQueue.get())
       
               # run this method again after 10ms
   71:         if self.alive:
   71:             self.after(10, self.writeLoop)
       
    1:     def write(self, string):
    2:         self.ttyText.insert(tk.END, string)
    2:         self.ttyText.see(tk.END)
    2:         self.line_start += len(string)
       
       
    1: def main():
    1:     root = tk.Tk()
           # style = ttk.Style(root)
           # style.theme_use("")
       
    1:     root.option_add("*tearOff", False)
    1:     root.title("pyHeatTrace")
       
    1:     menubar = tk.Menu(root)
    1:     root.config(menu=menubar)
    1:     heatTrace(root, menubar)
    1:     root.mainloop()
       
       
    1: if __name__ == "__main__":
    1:     main()
